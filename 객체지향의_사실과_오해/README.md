# 객체지향의 사실과 오해

JAVA로 개발을 하면서 어떻게 하면 코드를 객체지향적으로 짤 수 있을까 ? 유연하고 확장성이 있는 코드를 짜기 위해 객체지향에 대한 이해를 높이기 위해 객체지향의 사실과 오해라는 책을 읽고 정리하게 되었다.


- [1. 협력하는 객체들의 공동체](#1-협력하는-객체들의-공동체)
- [2. 이상한 나라의 객체](#2-이상한-나라의-객체)
- [3. 타입과 추상화](#3-타입과-추상화)
- [4. 역할, 책임, 협력](#4-역할-책임-협력)
- [5. 책임과 메시지](#5-책임과-메시지)
- [6. 객체 지도](#6-객체-지도)

## 1 협력하는 객체들의 공동체

객체지향을 접한지 얼마 안된 초보자들의 오해는 객체지향의 중심을 클래스나 상속이라 생각하는 것이다. 하지만 객체지향 패러다임의 핵심은 클래스나 상속이 아닌 **자율적인 객체들의 협력**이다.

또한 객체지향의 목표는 실세계를 모방하는 것이 아니라 새로운 새계를 **창조**하는 것이다.
실세계의 자동차는 스스로 움직일 수도 없고 시동을 걸 수도 없다. 객체지향 속 자동차 객체는 스스로 움직일 수 있고 시동을 걸 수 있는 자율적인 객체이다.

### 객체지향의 본질

- 시스템을 상호작용하는 **자율**적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법
- 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택

### 훌륭한 객체지향 설계
- 코드를 담는 클래스의 관점에서 **메시지를 주고 받는 객체의 관점**으로 사고의 중심을 전환
- 중요한 것은 어떤 클래스가 필요한가가 아닌 객체들이 메시지를 주고받으며 협력하는 것
- 클래스의 구조와 메서드가 아니라 객체의 **역할, 책임, 협력**에 집중

객체지향은 **객체를 지향**하는 것이지 클래스를 지향하는 것이 아니다.


## 2 이상한 나라의 객체

객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 **캡슐화**함으로써 실세계 문제에 내재된 복잡성을 관리하려 한다. 

### 객체의 상태 
- 단순한 값과 객체의 조합(다른 객체를 참조하는 링크)으로 표현
- 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현
- 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티라 함

### 객체의 행동
- 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동
- 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달
- 객체는 행동을 통해 다른 객체와 협력 하므로 행동은 외부에 가시적이어야 함

### 식별자
- 객체를 구분하는 데 사용하는 객체의 프로퍼티
- 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할수 있음

### 객체의 특징
- 객체는 상태를 가지며 변경이 가능
- 객체의 상태를 변경시키는 것은 객체의 행동
- 객체는 어떤 상태에 있더라도 유일하게 식별이 가능

객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다. 객체는 상태를 캡슐 안에 감쳐둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 **방법** 역시 **행동**뿐이다. 

객체지향 설계를 할 때 중요한 것은 **상태를 먼저를 정의하는 것이 아니라 행동을 먼저 정의** 한후 상태를 결정하는 것이다. 


## 3 타입과 추상화

### 추상화
어떤 양상,  세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 **복잡도를 극복**하는 방법

### 타입
- 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용한다.
- 객체의 타입은 **객체의 행동**에 의해 결정된다.
- 객체가 어떤 데이터(속성)을 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 미치지 않는다.

### 타입의 특징
- 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다.
- 동일한 행동 - > 동일한 책임 -> 동일한 메시지 수신
- 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 이것은 다형성에 의미를 부여한다.
- 예를들어, 자동차라는 타입의 객체 소나타, K5는 내부적인 부품이나 구조가 다르더라도 달린다라는 운전자의 메시지를 수신해서 달리는 행동을 할 수 있다.

### 타입의 목적
- 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 어렵다.
- 객체의 상태 변화를 타입으로 추상화시켜 관리

객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한가지 방법이 클래스이다.

결국, 객체지향에서 중요한 것은 동적으로 변하는 객체의 상태를 변경하는 행위이다.
클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘이다. 




## 4 역할 책임 협력

###  책임
- 객체지향에서는 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 **행동**을 할 의무가 있는 경우 해당 객체가 **책임**을 가진다고 말한다.

### 책임의 분류
- 객체의 책임은 객체가 무엇을 알고 있는가와 무엇을 할 수 있는가로 구성된다
- 하는 것(doing)
	- 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
	- 다른 객체의 행동을 시작시키는 것
	- 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
	- 개인적인 정보에 관해 아는 것
	- 관련된 객체에 관해 아는 것
	- 자신이 유도하거나 계산할 수 있는것에 관해 아는 것

### 역할       
- **책임의 집합**이 의미 하는것
- 똑같은 책임을 수행할 수 있으면 역할은 대체 가능하다.

### 협력
 - 특정 문제를 해결하기 위해 객체들이 책임을 나누어 **상호작용** 하는 것
- 올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야 한다.
- 협력을 설계한다는 것은 협력에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정하는 것이다.
- 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.
- 협력이라는 실행 문맥에 안에서 각 객체의 책임을 **분배**해야 자율적인 동시에 충분히 **협력**적인 객체를 만들 수 있다.


### 객체지향 설계 기법

- 책임 주도 설계
	- 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 설계
- 디자인 패턴
	-  전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 **설계 템플릿**의 모음
	- 패턴은 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음이다.
- 테스트 주도 개발
	- 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식
	- 테스트 주도 개발의 핵심은 **테스트**가 아니라 **설계**를 위한 기법이다.
	- 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적합한지를 피드백 받는것이다.

## 5 책임과 메시지

### 자율적인 책임
- 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문
- 요청을 처리하기 위해 **객체가 수행하는 행동**을 책임이라고 한다.
- 따라서 객체가 **어떻게(how)해야** 하는가가 아니라 **무엇(what)을** 해야 하는가를 설명한다는 것이다. 객체는 무엇을 해야한다는 메시지를 수신했을 때 그것을 어떻게 처리하라는 메시지 없이도 자율적으로 행동을 할 수 있어야 한다.

### 메시지, 메서드
- 객체가 **다른 객체에 접근**할 수 있는 유일한 방법 
- 메시지는 단지 '무엇'이 실행되기를 바라는지만 명시하며, 객체는 메시지를 어떻게 처리할지에 대한 방법을 나타내는 메서드를 선택한다.

### 다형성 
- 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 메커니즘
- 다형성은 역할, 책임, 협력과도 깊은 관련이 있다.
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 

### 인터페이스

- 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 된다.
- 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식을 변경해도 인터페이스 사용자에게 영향을 미치지 않는다. ( 변경에 유연함)
- 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 문제 없이 상호작용 할 수 있음


### 인터페이스와 구현의 분리

- 객체를 설계할 때 객체 **외부에 노출**되는 인터페이스와 객체의 **내부에 숨겨지는** 구현을 명확하게 분리해야 함
- 인터페이스와 구현의 분리가 중요한 이유는 소프트웨어가 항상 **변경되기** 때문이다.
- 변경될 만한 부분을 객체의 내부에 숨겨 (캡슐화) 객체 외부에 영향을 미치지 않게 한다.

## 6 객체 지도

### 기능 설계와 구조 설계
- 소프트웨어 설계에는 두가지 측면이 존재한다.
- 기능 측면의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다.
- 구조 측면의 설계는 제품의 형태가 어떠해야 하는지(변경을 수용할 수 있는)에 초점을 맞춘다.

### 안정적인 재료: 구조
- 도메인 모델
	-  사용자가 프로그램을 사용하는 대상 역역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태
	- 도메인 모델을 기반으로 코드를 작성하는 이유는 도메인 모델이 제공하는 구조가 **안정적**이기 때문이다.

### 불안정한 재료 : 기능
- 유스케이스
	-  사용자와 시스템 간의 상호작용을 보여주는 텍스트
	- 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.
	- 사용자 인터페이스와 관련된 세부정보를 포함하지 말아야 한다.
	- 내부 설계와 관련된 정보를 포함하지 않는다.
	- 사용자가 시스템을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있는지에 관한 정보만 기술된다.

도메인 모델은 사람들의 머릿속에 들어있는 공유된 멘탈 모델이다.
안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하고 도메인 모델과 코드를 밀접하게 연관시키면 유지 보수하기 쉽고 유연한 객체지향 시스템을 만들 수 있다.







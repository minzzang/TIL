
# 메모리 관리
## 1. 주소 바인딩
- 프로세스의 논리적 주소를 물리적 메모리 주소로 연결 시켜주는 작업

- 주소 바인딩 방식
	- 컴파일 타임 바인딩  

		- 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지가 결정된다.

		-  물리적 메모리의 위치를 변경하고 싶을 때는 컴파일을 다시 해야 하는 단점이 있다.
	- 로드 타임 바인딩
		- 로더의 책임 하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리 위치가 고정된다.
	- 실행 시간 바인딩
		- 프로그램이 실행을 시작한 후에도 물리적 메모리 상의 주소가 변경될 수 있다.

		- CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다.
- MMU 기법
	- 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소를 알아낸다.

	- 기준 레지스터는 프로세스의 물리적 메모리 시작 주소를 가지고 있다.

## 2. 메모리 관련 용어
- 동적 로딩
	-  프로세스 내에서 실행에 필요한 루틴이 실제로 불릴 때마다 메모리에 적재한다. 

	- 사용되지 않는 많은 양의 코드가 메모리에 올라가는 것을 막아 메모리를 좀 더 효율적으로 사용할 수 있도록 해준다.

- 동적 연결 
	-  연결이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일과 이미 컴파일된 라이브러리 파일을 묶어 하나의 `실행 파일`을 생성하는 과정을 말한다.

	- 동적 연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 포그램의 실행 지연시키는 기법을 말한다.

- 스와핑
	-  메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것을 말한다.
## 3. 물리적 메모리의 할당 방식
-  고정 분할 방식
	- 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어 두고 각 분할에 하나의 프로세스를 적재한다.

	- 분할의 크기를 모두 동일하게 할 수도 있고 서로 다르게 할 수도 있다. 
	- 외부 조각과 내부 조각이 발생할 수 있다.
 
- 가변 분할 방식
	- 프로그램의 크기를 고려해서 메모리를 할당한다.
	- 외부 조각 문제가 발생할 수 있다.

	- 동적 메모리 할당 문제
		- fisrt-fit : 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당
		- best-fit : 크기가 n 이상인 가장 작은 가용 공간을 찾아 할당
		- worst-fit : best-fit에 반대로 가장 큰 가용 공간에 할당 
## 4. 페이징 기법
- 주소 변환 기법
	- CPU가 사용하는 논리적 주소를 페이지 번호와 페이지 오프셋으로 나누어 주소 변환에 사용한다.

	- 페이지 번호는 페이지 테이블의 인덱스로 사용되고, 해당 인덱스의 항목에는 그 페이지의 물리적 메모리 상의 기준 주소가 저장된다.
	- 따라서 물리적 메모리는 기준 주소값에 페이지 오프셋을 더한 값이다.

- 계층적 페이징
	- 페이지 테이블에 사용되는 메모리를 줄이기 위해 2단계 페이징 기법을 사용한다.

	- 2단계 페이징 기법에서는 외부 페이지 테이블과 내부 페이지 테이블의 두 단계에 걸친 페이지 테이블을 사용한다.
	- 계층적 페이징을 사용하면 메모리 공간의 이득을 볼 수 있지만 메모리에 접근해야 하는 횟수가 늘어 시간적인 손해가 따른다.
	 
## 5. 세그먼테이션
- 프로세스의 주소 공간을 의미 단위`(코드, 데이터, 스택)`의 세그먼트로 나누어 물리적 메모리에 올리는 기법이다.

- 세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용된다. 
	- 세그먼트 번호는 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를 나타낸다. 

	- 오프셋은 그 세그먼트 내에서 얼마만큼 떨어져 있는지 나타낸다.
- 세그먼트 테이블 각 항목에는 base와 limit를 가지고 있다.
	-  base는 물리적 메모리에서 그 세그먼트의 시작 위치를 나타낸다.

	-  limit는 세그먼트의 길이를 담고 있다.

-  세그먼트 각 테이블의 항목에는 보호 비트와 유효 비트를 둔다.
	- 보호 비트는 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는지를 나타낸다.

	- 유효 비트는 세그먼트가 현재 물리적 메모리에 적재 되어 있는지를 나타낸다.
-  세그먼테이션 기법에서도 공유 세그먼트 개념을 지원한다. 공유 세그먼트는 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 한다.
- 세그먼테이션 기법에서는 프로그램을 의미 단위로 나누기 때문에 세그먼트의 길이가 균일하지 않다. 그래서 가변 분할 방식과 마찬가지로 동적 메모리 할당 문제를 가지고 있다. 

